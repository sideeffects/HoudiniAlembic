from __future__ import print_function
import _alembic_hom_extensions as _abc
try:
    from hou import ui
except:
    ui = None

import sys
if sys.version_info.major >= 3:
    translate_util = str
else:
    import string as translate_util

_AbcModule = '__import__("_alembic_hom_extensions")'

def GetFileName(node):
    r = []
    for i in range(node.evalParm('numlayers')):
        if node.evalParm('enablelayer%d' % (i + 1,)):
            path = node.evalParm('layer%d' % (i + 1,))
            if path:
                r.append(path)
    p = node.evalParm('fileName')
    if p:
        r.append(p)
    return r

def BuildHierarchyRoot(rootNode):
    #For now delete the existing children.
    for child in rootNode.children():
        child.destroy()

    fileName = GetFileName(rootNode)
    if not fileName:
        if ui:
            ui.displayMessage(title='No Filename',
                text='Please enter an Alembic file to load.',
                severity=hou.severityType.Warning)
        else:
            print('No filename entered for Alembic scene.')
        return

    _abc.alembicClearArchiveCache(fileName)

    tree = _abc.alembicGetSceneHierarchy(fileName, "")
    if not tree:
        return

    pathList = [x for x in rootNode.evalParm('objectPath').strip('/').split('/') if x]
    _AbcWalker(fileName, rootNode).build(tree, pathList)

_primitiveTypes = frozenset((
    'polymesh',
    'subdmesh',
    'curves',
    'nupatch',
    'points',
))

_sanitizeTable = None

def _sanitizeName(name):
    def valid(i):
        ch = chr(i)
        if ch.isalnum():
            return ch
        return '_'
    global _sanitizeTable
    if not _sanitizeTable:
        # Full alphabet
        alpha = ''.join(map(chr, range(256)))
        xlate = ''.join(map(valid, range(256)))
        _sanitizeTable = translate_util.maketrans(alpha, xlate)
    name = translate_util.translate(name, _sanitizeTable)
    if name[0].isdigit():
        name = '_' + name
    return name

def _setParmValue(node, parmname, value):
    parm = node.parm(parmname)
    if parm:
        parm.set(value)

def _setNodeName(node, name):
    try:
        node.setName(name, True)
    except:
        node.setName(_sanitizeName(name), True)

def ExpressionToParm(srcParm, dstParm, isString=False):
    relPath = dstParm.node().relativePathTo(srcParm.node())
    dstParm.setExpression('%s("%s/%s")' % (
            'chs' if isString else 'ch', relPath, srcParm.name()),
            hou.exprLanguage.Hscript)

def ExpressionToFileNameParm(src, dest):
    ExpressionToParm(src.parm('fileName'), dest.parm('fileName'), True)
    p = src.parm('numlayers')
    ExpressionToParm(p, dest.parm('numlayers'), False)
    for i in range(p.evalAsInt()):
        name = 'enablelayer%d' % (i + 1,)
        ExpressionToParm(src.parm(name), dest.parm(name), False)
        name = 'layer%d' % (i + 1,)
        ExpressionToParm(src.parm(name), dest.parm(name), True)

def _setupAbcGeo(geo):
    # We've just created an empty geometry node, we need to add the
    # properties we want.
    # Add mantra default properties
    parms = ','.join([
            'categories',
            'reflectmask',
            'refractmask',
            'lightmask',
            '*rendersubd*',
            'shop_geometrypath'])
    hou.hscript('opproperty -f -F Render %s mantra,prman* %s' % (geo.path(), parms))

def ScanHierarchy(parentPath, childEntry, cameraPathList, createGeoNode, pathList):
    name, typeName, children = childEntry
    if pathList:
        if pathList[0] != name:
            return
        pathList = pathList[1:]

    currentPath = '%s/%s' % (parentPath, name)
    if typeName == 'camera':
        cameraPathList.append(currentPath)
    elif typeName == 'xform' or typeName == 'cxform':
        for entry in children:
            ScanHierarchy(currentPath, entry, cameraPathList, createGeoNode, pathList)
    elif typeName in _primitiveTypes:
        createGeoNode[0] = True

class _AbcWalker:
    def __init__(self, fileName, rootNode):
        self._fileName = fileName
        self._rootNode = rootNode
        self._buildSubnet = rootNode.evalParm('buildSubnet')
        self._channelRefs = rootNode.evalParm('channelRef')
        self._buildSingleGeoNode = rootNode.evalParm('buildSingleGeoNode')
        self._flatVisibility = rootNode.evalParm('flattenVisibility')
        self._userPropsLoadMode = rootNode.evalParm('loadUserProps')
        self._warnings = []

    def build(self, tree, pathList):
        if self._buildSingleGeoNode:
            createGeoNode = [False]

            for entry in tree[2]:
                cameraPathList = []
                entryPathList = pathList
                ScanHierarchy('', entry, cameraPathList, createGeoNode, entryPathList)

                # Build camera nodes
                for cameraPath in cameraPathList:
                    camera = [x for x in cameraPath.strip('/').split('/') if x]
                    self._walk(self._rootNode, '', entry, camera)

            # Build single geo node
            if createGeoNode[0]:
                self._createSingleGeoNode()
        else:
            for entry in tree[2]:
                self._walk(self._rootNode, '', entry, pathList)

        self._rootNode.layoutChildren()

        if not self._channelRefs:
            PushParametersToChildren(self._rootNode)
        if self._warnings:
            hou.ui.displayMessage('\n'.join(self._warnings), severity=hou.severityType.Warning)
            self._warnings = []

    def _createSingleGeoNode(self):
        objectPath = self._rootNode.evalParm('objectPath')

        currentNode = self._newAlembicNode(self._rootNode, 'geo', run_init_scripts=False)
        _setupAbcGeo(currentNode)

        _setNodeName(currentNode, 'geo')
        if self._flatVisibility:
            self._setVisibility(currentNode, objectPath)

        sopNode = currentNode.createNode('alembic')
        _setNodeName(sopNode, 'alembic')

        relPath = sopNode.relativePathTo(self._rootNode)
        hou.hscript("opmultiparm %s 'abcName#' '%s/abcName#' 'hName#' '%s/hName#'" % (
                sopNode.path(), relPath, relPath))

        _setParmValue(sopNode, "addpath", 0)
        if self._channelRefs:
            ExpressionToParm(self._rootNode.parm('remapAttributes'),
                sopNode.parm('remapAttributes'),
                isString=True)
            ExpressionToFileNameParm(self._rootNode, sopNode)
            ExpressionToParm(self._rootNode.parm('frame'), sopNode.parm('frame'))
            ExpressionToParm(self._rootNode.parm('fps'), sopNode.parm('fps'))
            ExpressionToParm(self._rootNode.parm('loadmode'), sopNode.parm('loadmode'))
            ExpressionToParm(self._rootNode.parm('viewportlod'), sopNode.parm('viewportlod'))
            ExpressionToParm(self._rootNode.parm('loadUserProps'), sopNode.parm('loadUserProps'))

        sopNode.parm('objectPath').set(objectPath)
        sopNode.parm('includeXform').set(1)
        sopNode.parm('usevisibility').set(1)
        sopNode.parm('loadUserProps').set(self._userPropsLoadMode)
        sopNode.parm('groupnames').set('none')

    def _walk(self, parentNode, parentPath, childEntry, pathList):
        name, typeName, children = childEntry
        if pathList:
            if pathList[0] != name:
                return
            pathList = pathList[1:]

        currentPath = '%s/%s' % (parentPath, name)
        if typeName in _primitiveTypes:
            currentNode = self._newAlembicNode(parentNode, 'geo', run_init_scripts=False)
            #currentNode = parentNode.createNode('geo', run_init_scripts=False)
            #currentNode.setInput(0, parentNode.indirectInputs()[0])
            subd = (typeName == 'subdmesh')
            _setupAbcGeo(currentNode)
            if subd:
                for parmname in ('vm_rendersubd', 'ri_rendersubd'):
                    _setParmValue(currentNode, parmname, 1)
            _setNodeName(currentNode, name)
            if self._flatVisibility:
                self._setVisibility(currentNode, currentPath)

            sopNode = currentNode.createNode('alembic')
            _setNodeName(sopNode, name)

            relPath = sopNode.relativePathTo(self._rootNode)
            hou.hscript("opmultiparm %s 'abcName#' '%s/abcName#' 'hName#' '%s/hName#'" % (
                    sopNode.path(), relPath, relPath))

            _setParmValue(sopNode, "addpath", 0)
            if self._channelRefs:
                ExpressionToParm(self._rootNode.parm('remapAttributes'),
                    sopNode.parm('remapAttributes'),
                    isString=True)
                ExpressionToFileNameParm(self._rootNode, sopNode)
                ExpressionToParm(self._rootNode.parm('frame'), sopNode.parm('frame'))
                ExpressionToParm(self._rootNode.parm('fps'), sopNode.parm('fps'))
                ExpressionToParm(self._rootNode.parm('loadmode'), sopNode.parm('loadmode'))
                ExpressionToParm(self._rootNode.parm('viewportlod'), sopNode.parm('viewportlod'))
                ExpressionToParm(self._rootNode.parm('loadUserProps'), sopNode.parm('loadUserProps'))

            objectPath = currentPath
            if ' ' in objectPath:
                objectPath = ''.join(['"', currentPath, '"'])
            sopNode.parm('objectPath').set(objectPath)
            sopNode.parm('includeXform').set(0)
            sopNode.parm('usevisibility').set(not self._flatVisibility)
            sopNode.parm('loadUserProps').set(self._userPropsLoadMode)
            sopNode.parm('groupnames').set('none')  # Don't build groups

        elif typeName == 'camera':
            currentNode = self._newAlembicNode(parentNode, 'cam')
            _setNodeName(currentNode, name)
            parent = currentNode.parent()
            sampleTime = parent.parm('frame').eval() / parent.parm('fps').eval()
            cameraDict = _abc.alembicGetCameraDict(self._fileName, currentPath, sampleTime)

            # Set Houdini camera parameters
            if cameraDict != None:
                rootpath = currentNode.relativePathTo(self._rootNode)
                for parmName in (
                        'aperture',
                        'aspect',
                        'focal',
                        'near',
                        'far',
                        'focus',
                        'fstop',
                        'shutter',
                        'winx',
                        'winy',
                        'winsizex',
                        'winsizey'):
                    currentNode.parm(parmName).setExpression('root = hou.pwd().node(%s)\nreturn %s.alembicGetCameraDict(root.hdaModule().GetFileName(root), %s, root.evalParm("frame")/root.evalParm("fps")).get(%s)' % (repr(rootpath), _AbcModule, repr(currentPath), repr(parmName)), hou.exprLanguage.Python)

                resTuple = _abc.alembicGetCameraResolution(self._fileName, currentPath, sampleTime)

                if resTuple != None:
                    currentNode.parm('resx').set(resTuple[0])
                    currentNode.parm('resy').set(resTuple[1])

                # Some imported camera (ex. Maya Camera) does not have a resolution.
                # In this case, set the Houdini Camera resolution according to the film aspect ratio.
                else:
                    resy = currentNode.parm('resx').eval() / cameraDict['filmaspectratio']
                    currentNode.parm('resy').set(int(resy))
        else:
            if typeName != 'xform' and typeName != 'cxform':
                self._warnings.append('Found Alembic object with unknown type: %s' % (currentPath, ))
            currentNode = None
            if self._buildSingleGeoNode:
                currentNode = self._findNode(parentNode, currentPath)

            if not currentNode:
                currentNode = self._newAlembicNode(parentNode, 'alembicxform')

                _setNodeName(currentNode, name)

                animated = (typeName == 'xform')
                if self._setUserProperties(currentNode, currentPath):
                    animated = True

                if self._flatVisibility:
                    if self._checkAnimatedVisibility(currentPath):
                        animated = True
                else:
                    if self._setVisibility(currentNode, currentPath):
                        animated = True

                if self._channelRefs:
                    ExpressionToFileNameParm(self._rootNode, currentNode)
                    if animated:
                        ExpressionToParm(self._rootNode.parm('frame'),
                                currentNode.parm('frame'))
                        ExpressionToParm(self._rootNode.parm('fps'),
                                currentNode.parm('fps'))

                currentNode.parm('objectPath').set(currentPath)
                if not animated:
                    currentNode.parm('abcConstant').set(1)

            for entry in children:
                self._walk(currentNode, currentPath, entry, pathList)

            currentNode.layoutChildren()

    def _findNode(self, parentNode, currentPath):
        if self._buildSubnet:
            rootNode = parentNode
        else:
            rootNode = self._rootNode
        for child in rootNode.children():
            objPath = child.parm('objectPath')
            if not objPath:
                continue
            if currentPath == objPath.eval():
                return child

    def _setUserProperties(self, currentNode, currentPath):
        # Exit quick if user properties shouldn't be loaded
        if self._userPropsLoadMode == 0:
            return False

        # Check for user properties on node. Returns None if no user properties,
        # true if properties are static, and false if properties are animated.
        props = _abc.alembicHasUserProperties(self._fileName, currentPath)

        if props is not None:
            # Add spare parameter(s) for user properties
            currentNode.addSpareParmTuple(hou.StringParmTemplate('userProps', 'User Properties', 1, ['']))
            if self._userPropsLoadMode == 2:
                currentNode.addSpareParmTuple(hou.StringParmTemplate('userPropsMeta', 'User Properties Metadata', 1, ['']))

            if props and (self._userPropsLoadMode == 2):
                values, metadata = _abc.alembicUserPropertyValuesAndMetadata(self._fileName, currentPath, 0)
                currentNode.parm('userProps').set(values)
                currentNode.parm('userPropsMeta').set(metadata)
            elif props:
                currentNode.parm('userProps').set(_abc.alembicUserPropertyValues(self._fileName, currentPath, 0))
            else:
                if (self._userPropsLoadMode == 2):
                    expr = '%s.alembicUserPropertyMetadata(%s, %s, ch("frame")/ch("fps"))' % (_AbcModule, repr(self._fileName), repr(currentPath))
                    currentNode.parm('userPropsMeta').setExpression(expr, hou.exprLanguage.Python)

                expr = '%s.alembicUserPropertyValues(%s, %s, ch("frame")/ch("fps"))' % (_AbcModule, repr(self._fileName), repr(currentPath))
                currentNode.parm('userProps').setExpression(expr, hou.exprLanguage.Python)
                return True
        return False

    def _checkAnimatedVisibility(self, objectpath):
        vis = _abc.alembicVisibility(self._fileName, objectpath, 0, 1)
        return not vis[1] and vis[0] != -1

    def _setVisibility(self, node, objectpath):
        filename = self._fileName
        vis = _abc.alembicVisibility(filename, objectpath, 0)

        if vis == None:
            # Always visible - this is likely to occur when we reach the Alembic
            # root.
            return False;

        if vis[1]:
            if vis[0] == 0:
                # Never visible (constant hidden)
                _setParmValue(node, 'tdisplay', 1)
                _setParmValue(node, 'display', 0)

            elif vis[0] == -1:
                # Always whatever parent is (constant deferred)
                ppath = objectpath[:objectpath.rfind('/')]

                if ppath != "":
                    return self._setVisibility(node, ppath)
            return False
        # Animated visibility
        if len(filename):
            parm = node.parm('numlayers')
            if parm:
                layers = filename[:-1]
                parm.set(len(layers))
                for i, name in enumerate(layers):
                    _setParmValue(node, 'enablelayer%d' % (i + 1, ), 1)
                    _setParmValue(node, 'layer%d' % (i + 1, ), name)
            _setParmValue(node, 'fileName', filename[-1])
        _setParmValue(node, 'tdisplay', 1)

        disp = node.parm('display')
        expr = 'node = hou.pwd()\nif node.type().name() != "alembicxform":\n    node = node.parent()\nreturn %s.alembicVisibility(node.hdaModule().GetFileName(node), %s, node.evalParm("frame")/node.evalParm("fps"), 1)[0]' % (_AbcModule, repr(objectpath))
        disp.setExpression(expr, hou.exprLanguage.Python)
        return True

    def _newAlembicNode(self, parent, node_type, run_init_scripts=True):
        if self._buildSubnet:
            node = parent.createNode(node_type, run_init_scripts=run_init_scripts)
            node.setInput(0, parent.indirectInputs()[0])
        else:
            node = self._rootNode.createNode(node_type, run_init_scripts=run_init_scripts)
            if node.parent() == parent.parent():
                node.setInput(0, parent)
            else:
                node.setInput(0, parent.indirectInputs()[0])
        return node

def PushParametersToChildren(rootNode):
    WalkAndPush(rootNode, rootNode)

def ReloadGeometry(rootNode):
    for child in rootNode.children():
        if child.parm('reload') != None:
            child.parm('reload').pressButton()
        if not child.isLockedHDA():
            ReloadGeometry(child)

def _pushStringParm(name, fnode, tnode):
    tparm = tnode.parm(name)
    if tparm == None:
        return

    fparm = fnode.parm(name)
    if len(fparm.keyframes()) == 0:
        # Push the value
        tparm.set(fparm.unexpandedString())
    else:
        # We can't easily push channels to the children, so in this
        # case, we need to set channel references.
        tparm.deleteAllKeyframes()
        ExpressionToParm(fparm, tparm, True)

def _pushScalarParm(name, fnode, tnode):
    tparm = tnode.parm(name)
    if tparm:
        fparm = fnode.parm(name)
        try:
            expr = fparm.expression()
            tparm.setExpression(expr)
        except:
            tparm.deleteAllKeyframes()
            tparm.set(fparm.eval())

def _pushRemapAttributesParm(fnode, tnode):
    tparm = tnode.parm('remapAttributes')
    if tparm:
        fparm = fnode.parm('remapAttributes')
        nparms = fparm.eval()
        tparm.set(nparms)
        for i in range(nparms):
            _pushStringParm('abcName%d' % (i+1), fnode, tnode)
            _pushStringParm('hName%d' % (i+1), fnode, tnode)

def WalkAndPush(rootNode, parentNode):
    for kid in parentNode.children():
        _pushStringParm('fileName', rootNode, kid)
        p = rootNode.parm('numlayers')
        if p:
            _pushScalarParm('numlayers', rootNode, kid)
            for i in range(p.evalAsInt()):
                _pushScalarParm('enablelayer%d' % (i + 1,), rootNode, kid)
                _pushStringParm('layer%d' % (i + 1,), rootNode, kid)
        cxform = kid.parm('abcConstant')
        if not cxform or not cxform.eval():
            _pushScalarParm('frame', rootNode, kid)
            _pushScalarParm('fps', rootNode, kid)
            _pushScalarParm('loadmode', rootNode, kid)
            _pushScalarParm('viewportlod', rootNode, kid)
            _pushScalarParm('loadUserProps', rootNode, kid)
            _pushRemapAttributesParm(rootNode, kid)
        WalkAndPush(rootNode, kid)
